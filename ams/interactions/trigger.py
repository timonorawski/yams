"""
Trigger state manager for the unified interaction system.

Tracks interaction state between frames to enable enter/exit/continuous
trigger modes.

Trigger modes:
- enter: Fire once when filter becomes true
- exit: Fire once when filter becomes false
- continuous: Fire every frame while filter is true
"""

from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Optional, Set, Tuple

from .parser import Interaction, TriggerMode


@dataclass
class TriggerEvent:
    """
    An event generated by the trigger manager.

    Attributes:
        interaction: The interaction definition that fired
        entity_a_id: Entity A identifier
        entity_b_id: Entity B identifier
        trigger_type: The trigger mode that caused this event
        context: Computed interaction context (distance, angle, etc.)
    """
    interaction: Interaction
    entity_a_id: str
    entity_b_id: str
    trigger_type: TriggerMode
    context: Dict[str, Any]


class TriggerManager:
    """
    Manages trigger state for interactions.

    Tracks which entity pairs have matching filters to enable
    enter/exit detection.

    Usage:
        manager = TriggerManager()

        # Each frame:
        for entity_a in entities:
            for interaction in entity_a.interactions:
                for entity_b in potential_targets:
                    filter_matches = evaluate_filter(...)
                    events = manager.update(
                        interaction, entity_a.id, entity_b.id, filter_matches, context
                    )
                    for event in events:
                        execute_action(event)
    """

    def __init__(self):
        # State tracking: {(interaction_key, entity_a_id, entity_b_id): was_matching}
        self._state: Dict[Tuple[str, str, str], bool] = {}

        # Counter for generating interaction keys
        self._interaction_keys: Dict[int, str] = {}

    def _get_interaction_key(self, interaction: Interaction) -> str:
        """Get a stable key for an interaction."""
        # Use id() for now - in practice, interactions are stable per entity type
        int_id = id(interaction)
        if int_id not in self._interaction_keys:
            self._interaction_keys[int_id] = f"{interaction.source_entity_type}:{interaction.target}:{interaction.action}"
        return self._interaction_keys[int_id]

    def update(
        self,
        interaction: Interaction,
        entity_a_id: str,
        entity_b_id: str,
        filter_matches: bool,
        context: Optional[Dict[str, Any]] = None
    ) -> List[TriggerEvent]:
        """
        Update trigger state and return events to fire.

        Args:
            interaction: The interaction being evaluated
            entity_a_id: Entity A identifier
            entity_b_id: Entity B identifier
            filter_matches: Whether the filter currently matches
            context: Interaction context (distance, angle, etc.)

        Returns:
            List of TriggerEvents to fire (0, 1, or more)
        """
        key = (self._get_interaction_key(interaction), entity_a_id, entity_b_id)
        was_matching = self._state.get(key, False)

        # Update state
        self._state[key] = filter_matches

        events = []
        ctx = context or {}

        if interaction.trigger == TriggerMode.ENTER:
            # Fire once when filter becomes true
            if filter_matches and not was_matching:
                events.append(TriggerEvent(
                    interaction=interaction,
                    entity_a_id=entity_a_id,
                    entity_b_id=entity_b_id,
                    trigger_type=TriggerMode.ENTER,
                    context=ctx,
                ))

        elif interaction.trigger == TriggerMode.EXIT:
            # Fire once when filter becomes false
            if not filter_matches and was_matching:
                events.append(TriggerEvent(
                    interaction=interaction,
                    entity_a_id=entity_a_id,
                    entity_b_id=entity_b_id,
                    trigger_type=TriggerMode.EXIT,
                    context=ctx,
                ))

        elif interaction.trigger == TriggerMode.CONTINUOUS:
            # Fire every frame while filter is true
            if filter_matches:
                events.append(TriggerEvent(
                    interaction=interaction,
                    entity_a_id=entity_a_id,
                    entity_b_id=entity_b_id,
                    trigger_type=TriggerMode.CONTINUOUS,
                    context=ctx,
                ))

        return events

    def clear_entity(self, entity_id: str) -> None:
        """
        Clear all state for an entity (when destroyed).

        Removes all entries where entity_id is A or B.
        """
        keys_to_remove = [
            key for key in self._state
            if key[1] == entity_id or key[2] == entity_id
        ]
        for key in keys_to_remove:
            del self._state[key]

    def clear_pair(
        self,
        interaction: Interaction,
        entity_a_id: str,
        entity_b_id: str
    ) -> None:
        """Clear state for a specific entity pair."""
        key = (self._get_interaction_key(interaction), entity_a_id, entity_b_id)
        if key in self._state:
            del self._state[key]

    def get_state(
        self,
        interaction: Interaction,
        entity_a_id: str,
        entity_b_id: str
    ) -> bool:
        """Get current state for an entity pair."""
        key = (self._get_interaction_key(interaction), entity_a_id, entity_b_id)
        return self._state.get(key, False)

    def reset(self) -> None:
        """Clear all state (e.g., on level reset)."""
        self._state.clear()

    def get_active_pairs(self, interaction: Interaction) -> List[Tuple[str, str]]:
        """
        Get all entity pairs where the filter is currently matching.

        Useful for debugging and visualization.
        """
        int_key = self._get_interaction_key(interaction)
        return [
            (key[1], key[2])
            for key, matching in self._state.items()
            if key[0] == int_key and matching
        ]


@dataclass
class LifecycleEvent:
    """
    A lifecycle event (spawn, update, destroy).

    Used for level entity interactions.
    """
    entity_id: str
    event_type: str  # "spawn", "update", "destroy"
    cause: Optional[str] = None  # "transform", "spawn", "destroy"


class LifecycleManager:
    """
    Manages lifecycle triggers for level entity interactions.

    Tracks entity lifecycle state for enter/exit triggers on level.

    Usage:
        manager = LifecycleManager()

        # On entity spawn:
        events = manager.on_spawn(entity_id)

        # Each frame:
        events = manager.on_update(entity_id)

        # On entity destroy:
        events = manager.on_destroy(entity_id)
    """

    def __init__(self):
        # Track which entities exist
        self._entities: Set[str] = set()

        # Track which entities have fired their initial spawn
        self._spawned: Set[str] = set()

    def on_spawn(
        self,
        entity_id: str,
        cause: str = "spawn"
    ) -> List[LifecycleEvent]:
        """
        Handle entity spawn.

        Args:
            entity_id: The spawned entity
            cause: Why the entity was spawned ("spawn", "transform")

        Returns:
            List of lifecycle events (spawn trigger)
        """
        self._entities.add(entity_id)

        events = []
        if entity_id not in self._spawned:
            self._spawned.add(entity_id)
            events.append(LifecycleEvent(
                entity_id=entity_id,
                event_type="spawn",
                cause=cause,
            ))

        return events

    def on_update(self, entity_id: str) -> List[LifecycleEvent]:
        """
        Handle entity update (continuous trigger).

        Returns update event if entity exists.
        """
        if entity_id in self._entities:
            return [LifecycleEvent(
                entity_id=entity_id,
                event_type="update",
            )]
        return []

    def on_destroy(
        self,
        entity_id: str,
        cause: str = "destroy"
    ) -> List[LifecycleEvent]:
        """
        Handle entity destruction.

        Args:
            entity_id: The destroyed entity
            cause: Why the entity was destroyed ("destroy", "transform")

        Returns:
            List of lifecycle events (destroy trigger)
        """
        events = []
        if entity_id in self._entities:
            self._entities.discard(entity_id)
            self._spawned.discard(entity_id)
            events.append(LifecycleEvent(
                entity_id=entity_id,
                event_type="destroy",
                cause=cause,
            ))

        return events

    def on_transform(
        self,
        entity_id: str,
        fire_lifecycle: bool = False
    ) -> List[LifecycleEvent]:
        """
        Handle entity transform (type change).

        By default, transform doesn't fire lifecycle triggers.
        Set fire_lifecycle=True to fire exit on old type, enter on new.

        Args:
            entity_id: The transformed entity
            fire_lifecycle: Whether to fire exit/enter triggers

        Returns:
            List of lifecycle events (empty unless fire_lifecycle=True)
        """
        events = []
        if fire_lifecycle and entity_id in self._entities:
            # Fire exit for old type
            events.append(LifecycleEvent(
                entity_id=entity_id,
                event_type="destroy",
                cause="transform",
            ))
            # Fire enter for new type
            events.append(LifecycleEvent(
                entity_id=entity_id,
                event_type="spawn",
                cause="transform",
            ))

        return events

    def clear(self) -> None:
        """Clear all state (e.g., on level reset)."""
        self._entities.clear()
        self._spawned.clear()

    def entity_exists(self, entity_id: str) -> bool:
        """Check if entity is currently tracked."""
        return entity_id in self._entities
